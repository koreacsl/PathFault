import os
import time
import click
from pathfault.logger import setup_logger

# Import service commands to invoke in sequence
from pathfault.modules.core.exploit_payload_generator.services.generate_exploit_payloads import cli_generate_exploit_payloads
from pathfault.modules.core.exploit_payload_generator.services.validate_exploit_payloads import cli_validate_exploit_payloads

logger = setup_logger(__name__)

@click.command("generate-validated-exploit-payloads")
@click.option(
    "--gen-target-path", required=True,
    help="Target output URL for exploit generation"
)
@click.option(
    "--gen-surrogate-model", "gen_surrogate_model_path", required=True,
    help="Path to surrogate model Python file for generation"
)
@click.option(
    "--gen-smt-timeout", "gen_smt_timeout", default=10, type=int,
    show_default=True,
    help="SMT solving timeout in seconds for generation"
)
@click.option(
    "--gen-max-transformation-num", "gen_max_transformation_num", default=1, type=int,
    show_default=True,
    help="Maximum number of transformations per server for generation"
)
@click.option(
    "--gen-max-workers", "gen_max_workers", default=6, type=int,
    show_default=True,
    help="Number of parallel worker processes for generation"
)
@click.option(
    "--gen-random-seed", "gen_random_seed", default=None, type=int,
    help="Random seed for deterministic behavior in generation"
)
@click.option(
    "--gen-output", "gen_output",
    default="./pathfault/results/exploit_payload_generator/exploit_generation_output.json",
    show_default=True,
    help="Output log file path (JSON) for generation"
)
@click.option(
    "--val-smt-timeout", "val_smt_timeout", default=None, type=int,
    help="SMT solving timeout in seconds for validation (defaults to generation setting)"
)
@click.option(
    "--val-random-seed", "val_random_seed", default=None, type=int,
    help="Random seed for deterministic behavior in validation (defaults to generation setting)"
)
@click.option(
    "--val-output", "val_output", default="./pathfault/results/exploit_payload_generator/exploit_validation_output.json",
    show_default=True,
    help="Output log file path (JSON) for validation"
)
def cli_generate_validated_exploit_payloads(
    gen_target_path,
    gen_surrogate_model_path,
    gen_smt_timeout,
    gen_max_transformation_num,
    gen_max_workers,
    gen_random_seed,
    gen_output,
    val_smt_timeout,
    val_random_seed,
    val_output
):
    """
    1) Generate exploit payloads
    2) Validate those payloads
    """
    ctx = click.get_current_context()

    # Step 1: generation
    logger.info("Step 1: Generating exploit payloads...")
    ctx.invoke(
        cli_generate_exploit_payloads,
        target_path=gen_target_path,
        surrogate_model_path=gen_surrogate_model_path,
        smt_timeout=gen_smt_timeout,
        max_transformation_num=gen_max_transformation_num,
        max_workers=gen_max_workers,
        random_seed=gen_random_seed,
        output=gen_output
    )

    # Step 2: validation
    # Use the generation output JSON as the validation-json input
    effective_val_timeout = val_smt_timeout if val_smt_timeout is not None else gen_smt_timeout
    effective_val_seed = val_random_seed if val_random_seed is not None else gen_random_seed

    logger.info("Step 2: Validating generated payloads...")
    ctx.invoke(
        cli_validate_exploit_payloads,
        target_path=gen_target_path,
        surrogate_model_path=gen_surrogate_model_path,
        smt_timeout=effective_val_timeout,
        random_seed=effective_val_seed,
        validation_json=gen_output,
        output=val_output
    )

    logger.info("ðŸŽ¯ Complete: generated payloads in %s and validation log in %s", gen_output, val_output)


if __name__ == "__main__":
    cli_generate_validated_exploit_payloads()