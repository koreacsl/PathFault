import random
import importlib.util
import sys
import time
import json
import pickle
import base64
import subprocess
from datetime import datetime
from pathlib import Path

import click
from pathfault.logger import setup_logger
from pathfault.modules.core.exploit_payload_generator.logger import setup_smt_logger

logger = setup_logger(__name__)
smt_logger = setup_smt_logger(__name__)


def find_project_root() -> Path:
    """
    Walk up from this file until we find manage.py, and return that directory.
    """
    p = Path(__file__).resolve()
    for parent in p.parents:
        if (parent / "manage.py").exists():
            return parent
    raise RuntimeError("manage.py not found in any parent directory")


def run_subprocess_validate(servers, input_path, target_path, timeout_ms, random_seed=None):
    """
    servers: list of Server objects
    input_url: str
    target_path: str
    timeout_ms: int
    random_seed: Optional[int]
    """
    try:
        pickled = pickle.dumps(servers)
    except Exception as e:
        logger.error("Failed to pickle servers: %s", e)
        return None

    pickled_b64 = base64.b64encode(pickled).decode('utf-8')
    payload = {
        "pickled_servers": pickled_b64,
        "input_url": input_path,
        "target_path": target_path,
        "timeout": timeout_ms,
        "random_seed": random_seed
    }

    module = "pathfault.modules.core.exploit_payload_generator.services.solver_process.exploit_validation_process"
    project_root = find_project_root()

    proc = subprocess.run(
        [sys.executable, "-m", module],
        input=json.dumps(payload),
        text=True,
        capture_output=True,
        cwd=str(project_root),
    )

    if proc.returncode != 0:
        logger.error("exploit_validation_process exited with code %d", proc.returncode)
        logger.error("stderr: %s", proc.stderr.strip())
        logger.error("stdout: %s", proc.stdout.strip())
        return None

    try:
        return json.loads(proc.stdout)
    except json.JSONDecodeError as e:
        logger.error("JSON parsing error: %s", e)
        logger.error("stdout: %s", proc.stdout.strip())
        return None

@click.command("validate-exploit-payloads")
@click.option(
    "--target-path", "target_path",
    required=True,
    help="Target input URL"
)
@click.option(
    "--surrogate-model", "surrogate_model_path",
    required=True,
    help="Path to surrogate model Python file (overridden by JSON file value if provided)"
)
@click.option(
    "--smt-timeout", default=10, type=int,
    help="SMT solving timeout in seconds"
)
@click.option(
    "--random-seed", default=None, type=int,
    help="Random seed for deterministic behavior"
)
@click.option(
    "--validation-json", "validation_json", required=True,
    help="Path to JSON file containing 'final_transformed_urls'"
)
@click.option(
    "--output", "output", default="./pathfault/results/exploit_payload_generator/exploit_validation_output.json",
    help="Output log file path (JSON format)"
)
def cli_validate_exploit_payloads(
    target_path,
    surrogate_model_path,
    smt_timeout,
    random_seed,
    validation_json,
    output
):
    """
    Validation for Path Confusion Exploits via HTTP message parser discrepancies.
    """
    import multiprocessing
    multiprocessing.freeze_support()

    # Load validation candidates and output_url from JSON
    try:
        with open(validation_json, "r", encoding="utf-8") as f:
            data = json.load(f)
        validation_candidates = data.get("final_transformed_urls", [])
        json_model = data.get("options", {}).get("surrogate_model")
    except Exception as e:
        logger.error("Error loading validation JSON: %s", e)
        raise click.UsageError("Could not read validation JSON")

    if json_model:
        surrogate_model_path = json_model
        logger.info("Found surrogate_model in JSON: %s", surrogate_model_path)

    if not validation_candidates:
        logger.info("No candidates found in validation JSON. Exiting.")
        empty = {
            "execution_time": 0,
            "validation_results": {},
            "candidate_summary": {
                "input_candidates": [],
                "removed_candidates": [],
                "successful_candidates": [],
                "counts": {"input": 0, "removed": 0, "successful": 0, "total": 0}
            }
        }
        with open(output, "w", encoding="utf-8") as f:
            json.dump(empty, f, indent=2)
        logger.info("Saved empty log to %s", output)
        return

    logger.info("Mode: VALIDATE")
    logger.info("Target path: %s", target_path)
    logger.info("SMT timeout: %d seconds", smt_timeout)
    logger.info("Number of validation candidates: %d", len(validation_candidates))

    # Random seed selection
    if random_seed is None:
        random_seed = random.randint(1, 1_000_000)
        logger.info("Random seed selected: %d", random_seed)
    else:
        logger.info("Random seed provided: %d", random_seed)
    random.seed(random_seed)

    # Load surrogate model
    spec = importlib.util.spec_from_file_location("surrogate_model", surrogate_model_path)
    surrogate_mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(surrogate_mod)
    servers = surrogate_mod.get_surrogate_model()
    logger.info("Surrogate model loaded: %d servers found", len(servers))

    # Initialize log structure
    log_data = {
        "options": {
            "target_path": target_path,
            "surrogate_model": surrogate_model_path,
            "smt_timeout": smt_timeout,
            "random_seed": random_seed,
            "validation_candidates": validation_candidates
        },
        "execution_time": 0,
        "validation_results": {},
        "candidate_summary": {
            "input_candidates": [],
            "removed_candidates": [],
            "successful_candidates": [],
            "counts": {"input": 0, "removed": 0, "successful": 0, "total": 0}
        }
    }

    overall_start = time.time()
    candidate_results = {}

    for input_path in validation_candidates:
        ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        logger.info("Validating candidate %s at %s", input_path, ts)
        start = time.time()
        result = run_subprocess_validate(
            servers, input_path, target_path, smt_timeout * 1000, random_seed
        )
        elapsed = time.time() - start
        candidate_results[input_path] = {"execution_time": elapsed, "result": result}

        if result is None:
            smt_logger.smt_failed(f"Validation failed for {input_path} in {elapsed:.2f}s")
        elif not isinstance(result, dict):
            smt_logger.smt_failed(f"Validation error for {input_path} in {elapsed:.2f}s")
        else:
            if result.get("result") == "success":
                smt_logger.smt_success(f"Validation succeeded for {input_path}; time={elapsed:.2f}s")
            else:
                smt_logger.smt_failed(
                    f"Validation failed for {input_path} (conditions unsat); time={elapsed:.2f}s"
                )

    overall_end = time.time()
    log_data["execution_time"] = overall_end - overall_start
    log_data["validation_results"] = candidate_results

    # Candidate summary
    inputs = validation_candidates
    success_list, removed_list = [], []
    for cand, res in candidate_results.items():
        if (
            res["result"]
            and isinstance(res["result"], dict)
            and res["result"].get("result") == "success"
        ):
            success_list.append(cand)
        else:
            removed_list.append(cand)

    log_data["candidate_summary"]["input_candidates"] = inputs
    log_data["candidate_summary"]["successful_candidates"] = success_list
    log_data["candidate_summary"]["removed_candidates"] = removed_list
    log_data["candidate_summary"]["counts"] = {
        "input": len(inputs),
        "successful": len(success_list),
        "removed": len(removed_list),
        "total": len(inputs)
    }

    logger.info("Total execution time: %.2f seconds", log_data["execution_time"])
    logger.info("Total input candidates: %d", len(inputs))
    logger.info("Total successful candidates: %d", len(success_list))
    logger.info("Total removed candidates: %d", len(removed_list))

    with open(output, "w", encoding="utf-8") as f:
        json.dump(log_data, f, indent=2)
    logger.info("Log file saved to %s", output)

if __name__ == "__main__":
    cli_validate_exploit_payloads()