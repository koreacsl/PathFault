
import uuid
from pathlib import Path

from z3 import *
import sys

import base64
import pickle
import json
import subprocess

from pathfault.inconsistency.server import ServerAction
from typing import List


def find_project_root() -> Path:
    """
    Walks up from this file until it finds manage.py, and returns that directory.
    """
    p = Path(__file__).resolve()
    for parent in p.parents:
        if (parent / "manage.py").exists():
            return parent
    raise RuntimeError("manage.py not found in any parent directory")


def run_subprocess(server_actions, target_output, timeout_ms, random_seed=None):
    """
    server_actions: List[ServerAction]
    target_output: str
    timeout_ms: int
    random_seed: Optional[int] - Solver의 random seed
    """
    try:
        pickled = pickle.dumps(server_actions)
    except Exception as e:
        print(f"[❌ pickle.dumps(server_actions) 오류] {e}")
        return None

    pickled_b64 = base64.b64encode(pickled).decode('utf-8')

    payload = {
        "pickled_actions": pickled_b64,
        "target_output": target_output,
        "timeout": timeout_ms,
        "random_seed": random_seed  # random_seed 추가
    }

    # figure out module path, and repo root
    module = "pathfault.modules.core.exploit_payload_generator.services.solver_process.exploit_generation_process"
    project_root = find_project_root()

    proc = subprocess.run(
        [sys.executable, "-m", module],
        input=json.dumps(payload),
        text=True,
        capture_output=True,
        cwd=str(project_root)
    )

    if proc.returncode != 0:
        print(f"[❌ exploit_generation_process.py execution error] (returncode={proc.returncode})")
        print(f"stderr: {proc.stderr.strip()}")
        print(f"stdout: {proc.stdout.strip()}")
        return None

    try:
        resp = json.loads(proc.stdout)
        if "input_url" in resp:
            resp["input_url"] = resp["input_url"].strip('"')
        return resp
    except json.JSONDecodeError as e:
        print(f"[❌ JSON parsing error] {e}")
        print(f"stdout: {proc.stdout.strip()}")
        return None

    # if resp.get("result") == "success":
    #     return resp
    # else:
    #     return resp


def main():
    """
    stdin으로부터 base64 인코딩된 pickle (server_actions), target_output, timeout_ms, random_seed 등을 받아
    Z3 Solver 로직을 수행한 뒤, 반드시 JSON 형태로 stdout에 출력.
    """
    try:
        raw = sys.stdin.read()
        data = json.loads(raw)  # { pickled_actions, target_output, timeout, random_seed }
    except Exception as e:
        error_result = {"result": "error", "error": f"Invalid input JSON: {e}"}
        print(json.dumps(error_result))
        return

    try:
        pickled_actions = base64.b64decode(data["pickled_actions"])

        server_actions: List[ServerAction] = pickle.loads(pickled_actions)
    except Exception as e:
        error_result = {"result": "error", "error": f"Pickle load failed: {e}"}
        print(json.dumps(error_result))
        return

    target_output_str = data.get("target_output", "")
    timeout_ms = data.get("timeout", 10000)
    # random_seed 인자 읽기 (문자열일 경우 int 변환)
    random_seed = data.get("random_seed", None)
    if random_seed is not None:
        try:
            random_seed = int(random_seed)
        except ValueError:
            random_seed = None

    s = SolverFor("QF_S")
    s.set("smt.phase_selection", 5)  # 다양한 탐색 경로 선택
    s.set("smt.restart_strategy", 2)  # 빠른 백트래킹 설정
    s.set("smt.arith.random_initial_value", True)  # 초기 값 무작위 설정
    s.set("smt.arith.propagation_mode", 2)
    s.set("smt.delay_units", True)  # Unit Clause 학습 시 리스타트 지연
    s.set("smt.delay_units_threshold", 50)  # 최대 50개의 Unit Clause까지 지연
    s.set("smt.str.aggressive_value_testing", True)
    s.set("smt.str.fast_length_tester_cache", True)
    s.set("timeout", timeout_ms)

    # random_seed가 제공되었다면 solver에 전달
    if random_seed is not None:
        s.set("random_seed", random_seed)

    # original_input/current_input
    original_input_name = f"input_url_{uuid.uuid4().hex[:8]}"
    original_input = String(original_input_name)
    current_input = original_input

    combined_conditions = BoolVal(True)

    try:
        for server_action in server_actions:
            pre_conditions = server_action.apply_pre_conditions(current_input)
            combined_conditions = And(combined_conditions, pre_conditions)

            transformed_input, transformed_conditions = server_action.apply_transformations(current_input)
            combined_conditions = And(combined_conditions, transformed_conditions)

            normalized_input, normalized_conditions = server_action.apply_normalization(transformed_input)
            combined_conditions = And(combined_conditions, normalized_conditions)

            post_conditions = server_action.apply_post_conditions(normalized_input)
            combined_conditions = And(combined_conditions, post_conditions)

            current_input = normalized_input
    except Exception as e:
        error_result = {"result": "error", "error": f"apply_* error: {e}"}
        print(json.dumps(error_result))
        return

    combined_conditions = simplify(combined_conditions)

    s.add(combined_conditions)
    s.add(current_input == StringVal(target_output_str))

    try:
        status = s.check()
        if status == sat:
            model = s.model()
            found_input = model.eval(original_input, model_completion=True)
            result = {
                "result": "success",
                "input_url": str(found_input)
            }
        elif status == unsat:
            result = {"result": "failure"}
        else:
            result = {"result": "unknown"}
    except Exception as e:
        result = {"result": "error", "error": f"Solver check failed: {e}"}

    print(json.dumps(result))


if __name__ == "__main__":
    main()