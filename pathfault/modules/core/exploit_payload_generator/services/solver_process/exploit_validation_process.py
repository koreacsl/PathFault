import uuid
from z3 import *
import sys
import base64
import pickle
import json
from pathfault.inconsistency import Server
from typing import List

def main():
    """
    Read base64-encoded pickle (servers), input_url, target_path, timeout_ms, random_seed from stdin,
    run the Z3 solver logic, and always output valid JSON to stdout.
    """
    try:
        raw = sys.stdin.read()
        data = json.loads(raw)  # { pickled_servers, input_url, target_path, timeout, random_seed }
    except Exception as e:
        error_result = {"result": "error", "error": f"Invalid input JSON: {e}"}
        print(json.dumps(error_result))
        return

    try:
        pickled_servers = base64.b64decode(data["pickled_servers"])
        # servers may be a single Server object or a list of them
        servers: List[Server] = pickle.loads(pickled_servers)
    except Exception as e:
        error_result = {"result": "error", "error": f"Pickle load failed: {e}"}
        print(json.dumps(error_result))
        return

    input_url_str = data.get("input_url", "")
    target_path_str = data.get("target_path", "")
    timeout_ms = data.get("timeout", 10000)
    random_seed = data.get("random_seed", None)
    if random_seed is not None:
        try:
            random_seed = int(random_seed)
        except ValueError:
            random_seed = None

    # Configure Z3 solver
    s = SolverFor("QF_S")
    s.set("smt.phase_selection", 5)
    s.set("smt.restart_strategy", 2)
    s.set("smt.arith.random_initial_value", True)
    s.set("smt.arith.propagation_mode", 2)
    s.set("smt.delay_units", True)
    s.set("smt.delay_units_threshold", 50)
    s.set("smt.str.aggressive_value_testing", True)
    s.set("smt.str.fast_length_tester_cache", True)
    s.set("timeout", timeout_ms)
    if random_seed is not None:
        s.set("random_seed", random_seed)

    # force original_input to equal input_url_str
    original_input_name = f"input_url_{uuid.uuid4().hex[:8]}"
    original_input = String(original_input_name)
    s.add(original_input == StringVal(input_url_str))
    current_input = original_input

    combined_conditions = BoolVal(True)

    try:
        # if servers is a single object, convert to list
        if not isinstance(servers, list):
            servers = [servers]

        for server in servers:
            # Each Server must implement these methods:
            pre_conditions = server.apply_pre_conditions(current_input)
            combined_conditions = And(combined_conditions, pre_conditions)

            decoded_input = server.apply_decoding(current_input)

            transformed_input, transformed_conditions = server.apply_transformations(decoded_input)
            combined_conditions = And(combined_conditions, transformed_conditions)

            essential_transformed_input, essential_transformed_conditions = server.apply_essential_tranformation(transformed_input)
            combined_conditions = And(combined_conditions, essential_transformed_conditions)

            normalized_input, normalized_conditions = server.apply_normalization(essential_transformed_input)
            combined_conditions = And(combined_conditions, normalized_conditions)

            post_conditions = server.apply_post_conditions(normalized_input)
            combined_conditions = And(combined_conditions, post_conditions)

            current_input = normalized_input

    except Exception as e:
        error_result = {"result": "error", "error": f"apply_* error: {e}"}
        print(json.dumps(error_result))
        return

    combined_conditions = simplify(combined_conditions)
    s.add(combined_conditions)

    # verification: ensure final current_input equals target_path_str
    s.add(current_input == StringVal(target_path_str))

    try:
        status = s.check()
        if status == sat:
            model = s.model()
            validated_input = model.eval(original_input, model_completion=True)
            result = {"result": "success", "validated_input": str(validated_input)}
        elif status == unsat:
            result = {"result": "failure"}
        else:
            result = {"result": "unknown"}
    except Exception as e:
        result = {"result": "error", "error": f"Solver check failed: {e}"}

    print(json.dumps(result))

if __name__ == "__main__":
    main()