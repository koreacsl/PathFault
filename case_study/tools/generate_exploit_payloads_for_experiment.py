import os
import sys
import subprocess
import time
import json
import platform
import click


# ─────────────────────────────────────────────────────────────────────────────
# Helper: launch generate-exploit-payloads and capture /usr/bin/time statistics
# ─────────────────────────────────────────────────────────────────────────────
def run_generate_command(
    surrogate_model: str,
    target_path: str,
    max_transformation: int,
    timeout: int,
    max_workers: int,
    output_log: str,
):
    """
    Call PathFault’s **generate-exploit-payloads** (via *manage.py*), wrap the
    call in **/usr/bin/time**, then append RSS / CPU / wall-time information to
    the JSON log produced by PathFault.

    Only the `/usr/bin/time` parsing has been customised so macOS lines such as

        `318636032  maximum resident set size`

    are handled correctly. All generation logic remains untouched.
    """
    # ── locate project root (…/PathFault) and manage.py ──────────────────────
    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
    manage_py = os.path.join(project_root, "manage.py")
    surrogate_model_path = os.path.abspath(surrogate_model)

    # ── choose correct timing wrapper for the host OS ────────────────────────
    system_platform = platform.system()
    if system_platform == "Darwin":
        time_cmd = ["/usr/bin/time", "-l"]
    elif system_platform == "Linux":
        time_cmd = ["/usr/bin/time", "-v"]
    else:
        raise RuntimeError("Unsupported OS for timing command.")

    cmd = time_cmd + [
        sys.executable,
        manage_py,
        "core",
        "exploit-generator",
        "services",
        "generate-exploit-payloads",
        "--target-path",
        target_path,
        "--surrogate-model",
        surrogate_model_path,
        "--max-transformation-num",
        str(max_transformation),
        "--smt-timeout",
        str(timeout),
        "--max-workers",
        str(max_workers),
        "--output",
        output_log,                           # ← PathFault’s native --output option
    ]

    print(f"[⚙️  Running]: {' '.join(cmd)}")
    start_time = time.time()

    try:
        result = subprocess.run(cmd, cwd=project_root, capture_output=True, text=True, check=True)
        wall_time = time.time() - start_time

        # ── parse /usr/bin/time output (macOS & Linux) ───────────────────────
        max_rss = user_time = sys_time = None
        for line in result.stderr.splitlines():
            line = line.strip()

            if system_platform == "Darwin":
                # e.g. “318636032  maximum resident set size”
                if "maximum resident set size" in line.lower():
                    try:
                        max_rss = int(line.split()[0]) / 1024  # → MB
                    except ValueError:
                        print(f"[⚠️  Parse error] RSS line: {line}")

                # e.g. “        2.23 real  1.85 user  0.19 sys”
                elif line.startswith("real") and "user" in line and "sys" in line:
                    parts = line.split()
                    try:
                        user_time = float(parts[2])
                        sys_time = float(parts[4])
                    except (IndexError, ValueError):
                        print(f"[⚠️  Parse error] user/sys line: {line}")

            else:  # Linux output
                if line.startswith("Maximum resident set size"):
                    try:
                        max_rss = int(line.split(":")[-1].strip()) / 1024
                    except ValueError:
                        print(f"[⚠️  Parse error] RSS line: {line}")
                elif line.startswith("User time (seconds)"):
                    try:
                        user_time = float(line.split(":")[-1].strip())
                    except ValueError:
                        print(f"[⚠️  Parse error] user_time line: {line}")
                elif line.startswith("System time (seconds)"):
                    try:
                        sys_time = float(line.split(":")[-1].strip())
                    except ValueError:
                        print(f"[⚠️  Parse error] sys_time line: {line}")

        # ── enrich PathFault JSON with resource usage figures ────────────────
        if os.path.exists(output_log):
            with open(output_log, "r+", encoding="utf-8") as fp:
                data = json.load(fp)
                data["resource_usage"] = {
                    "max_memory_MB": round(max_rss, 2) if max_rss else None,
                    "cpu_user_time_sec": round(user_time, 2) if user_time else None,
                    "cpu_system_time_sec": round(sys_time, 2) if sys_time else None,
                    "wall_clock_time_sec": round(wall_time, 2),
                }
                fp.seek(0)
                json.dump(data, fp, indent=2)
                fp.truncate()

        print(f"[✅ Finished]: {output_log}")

    except subprocess.CalledProcessError as exc:
        print(f"[❌ Error] {exc}")
        print(exc.stderr)


# ──────────────────────────────── CLI ────────────────────────────────────────
@click.command()
@click.option("--surrogate-dir", required=True, help="Directory containing *.py surrogate-model files.")
@click.option("--iterations", required=True, type=int, help="How many runs per surrogate model.")
@click.option("--timeout", required=True, type=int, help="SMT timeout (seconds).")
@click.option("--max-transformation", required=True, type=int, help="Maximum transformations per server.")
@click.option("--target-path", required=True, help="Victim path passed to --target-path.")
@click.option("--max-workers", required=True, type=int, help="Parallel SMT workers.")
@click.option(
    "--results-dir",
    required=True,
    help="Output directory where *generation_results* will be stored "
         "(each surrogate model gets its own sub-folder).",
)
def main(
    surrogate_dir: str,
    iterations: int,
    timeout: int,
    max_transformation: int,
    target_path: str,
    max_workers: int,
    results_dir: str,
):
    """
    For every *.py file inside **SURROGATE_DIR** run the PathFault generator
    **ITERATIONS** times.  Resource-usage data are merged into each JSON log.
    All logs are written under **RESULTS_DIR**/generation_results/<model-name>/.
    """
    # create “…/generation_results/<surrogate-dir-name>”
    gen_root = os.path.join(os.path.abspath(results_dir))
    os.makedirs(gen_root, exist_ok=True)

    for py_file in os.listdir(surrogate_dir):
        if not py_file.endswith(".py"):
            continue

        model_name = py_file[:-3]
        model_out_dir = os.path.join(gen_root, model_name)
        os.makedirs(model_out_dir, exist_ok=True)

        for i in range(1, iterations + 1):
            out_log = os.path.join(model_out_dir, f"output_generation_{i}.json")
            run_generate_command(
                os.path.join(surrogate_dir, py_file),
                target_path,
                max_transformation,
                timeout,
                max_workers,
                out_log,
            )


if __name__ == "__main__":
    main()