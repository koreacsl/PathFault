#!/usr/bin/env python3
"""
Validate PathFault generation JSONs (via manage.py) and append resource-usage
statistics.

Only functional tweaks
----------------------
1.  The script now reads **both** `target_path` *and* `surrogate_model`
    from the generation JSON’s "options" object.
2.  Those values are passed to *manage.py validate-exploit-payloads* using
    the required CLI flags.

All /usr/bin/time parsing and log-annotation code remains untouched.
"""

from __future__ import annotations

import os
import sys
import subprocess
import argparse
import json
import time
import platform


# ─────────────────────────────────────────────────────────────────────────────
# Helper – invoke validator & capture /usr/bin/time output
# ─────────────────────────────────────────────────────────────────────────────
def run_validate_command(validation_json: str, timeout: int, output_log: str) -> None:
    project_root = os.path.abspath(
        os.path.join(os.path.dirname(__file__), "..", "..")
    )
    manage_py = os.path.join(project_root, "manage.py")

    # ── pull target-path and surrogate-model from the generation JSON ────────
    try:
        with open(validation_json, encoding="utf-8") as fp:
            opts = json.load(fp).get("options", {})
            target_path = opts.get("target_path") or opts.get("output_url") or "/"
            surrogate_model = opts.get("surrogate_model")
            if surrogate_model:
                surrogate_model = os.path.abspath(surrogate_model)
            else:
                raise KeyError("surrogate_model missing from options")
    except Exception as err:                                   # noqa: BLE001
        print(f"[⚠️  Could not extract options] {err}")
        return                                               # skip this file

    # choose timing wrapper
    system_platform = platform.system()
    if system_platform == "Darwin":
        time_cmd = ["/usr/bin/time", "-l"]
    elif system_platform == "Linux":
        time_cmd = ["/usr/bin/time", "-v"]
    else:
        raise RuntimeError("Unsupported OS for timing command.")

    cmd = time_cmd + [
        sys.executable,
        manage_py,
        "core",
        "exploit-generator",
        "services",
        "validate-exploit-payloads",
        "--validation-json", validation_json,
        "--target-path",     target_path,      # ← extracted
        "--surrogate-model", surrogate_model,  # ← extracted
        "--smt-timeout",     str(timeout),
        "--output",          output_log,
    ]

    print(f"[⚙️  Running]: {' '.join(cmd)}")
    start_time = time.time()

    try:
        result = subprocess.run(cmd, cwd=project_root, capture_output=True, text=True, check=True)
        wall_time = time.time() - start_time

        # ── original /usr/bin/time parsing (unchanged) ───────────────────────
        max_rss = user_time = sys_time = None
        for line in result.stderr.splitlines():
            ln = line.strip()

            if system_platform == "Darwin":
                if "maximum resident set size" in ln.lower():
                    try:
                        max_rss = int(ln.split()[0]) / 1024
                    except ValueError:
                        print(f"[⚠️  Parse error] RSS line: {ln}")
                elif ln.startswith("real") and "user" in ln and "sys" in ln:
                    parts = ln.split()
                    try:
                        user_time = float(parts[2])
                        sys_time  = float(parts[4])
                    except (IndexError, ValueError):
                        print(f"[⚠️  Parse error] user/sys line: {ln}")

            else:  # Linux
                if ln.startswith("Maximum resident set size"):
                    try:
                        max_rss = int(ln.split(":")[-1].strip()) / 1024
                    except ValueError:
                        print(f"[⚠️  Parse error] RSS line: {ln}")
                elif ln.startswith("User time (seconds)"):
                    try:
                        user_time = float(ln.split(":")[-1].strip())
                    except ValueError:
                        print(f"[⚠️  Parse error] user_time line: {ln}")
                elif ln.startswith("System time (seconds)"):
                    try:
                        sys_time = float(ln.split(":")[-1].strip())
                    except ValueError:
                        print(f"[⚠️  Parse error] sys_time line: {ln}")

        # ── merge resource stats into validation JSON ────────────────────────
        if os.path.exists(output_log):
            with open(output_log, "r+", encoding="utf-8") as fp:
                data = json.load(fp)
                data["resource_usage"] = {
                    "max_memory_MB":       round(max_rss, 2) if max_rss else None,
                    "cpu_user_time_sec":   round(user_time, 2) if user_time else None,
                    "cpu_system_time_sec": round(sys_time, 2) if sys_time else None,
                    "wall_clock_time_sec": round(wall_time, 2),
                }
                fp.seek(0)
                json.dump(data, fp, indent=2)
                fp.truncate()

        print(f"[✅  Done]: {output_log}")

    except subprocess.CalledProcessError as err:
        print(f"[❌  Error]: {err}")
        print(err.stderr)


# ────────────────────────────── CLI entry-point ─────────────────────────────
def main() -> None:
    parser = argparse.ArgumentParser(
        description="Validate PathFault generation JSON files."
    )
    parser.add_argument("--gen-dir", required=True, help="Directory with generation outputs.")
    parser.add_argument("--timeout", type=int, required=True, help="SMT timeout (s).")
    parser.add_argument("--val-dir", help="Destination root for validation logs.")
    args = parser.parse_args()

    case_study_root = os.path.abspath(os.path.join(args.gen_dir, "..", ".."))
    default_root = os.path.join(
        case_study_root,
        "validation_results",
        os.path.basename(args.gen_dir),
    )
    results_root = os.path.abspath(args.val_dir) if args.val_dir else default_root
    os.makedirs(results_root, exist_ok=True)

    for model_sub in os.listdir(args.gen_dir):
        gen_sub_dir = os.path.join(args.gen_dir, model_sub)
        if not os.path.isdir(gen_sub_dir):
            continue

        out_dir = os.path.join(results_root, model_sub)
        os.makedirs(out_dir, exist_ok=True)

        for fname in os.listdir(gen_sub_dir):
            if fname.startswith("output_generation_") and fname.endswith(".json"):
                validation_json = os.path.join(gen_sub_dir, fname)
                output_log = os.path.join(out_dir, fname.replace("output_generation", "output_validation"))
                run_validate_command(validation_json, args.timeout, output_log)


if __name__ == "__main__":
    main()